```toc

```
# Introduction
Une Cross Site Request Forgery (CSRF) permet a un attaquant de forcer sa victime à réaliser une action qu'elle ne souhaitait pas faire (changer son mot de passe, transférer de l'argent, ...).

Les actions des utilisateurs se font typiquement au travers de requête HTTP. Une requête est susceptible d'être vulnérable à une CSRF seulement si :
- La réalisation de l'action repose sur l'identification de l'utilisateur via un cookie de session et aucun autre mécanisme
- Aucun paramètre imprédictible par l'attaquant n'est nécessaire pour réaliser l'action (ex : jeton CSRF, mot de passe de l'utilisateur, ...)

## Requête GET
Dans le cas (assez rare) où une action sensible peut être réalisé avec un requête GET, il suffit pour l'attaquant de créer un URL intéressant et de le faire consulter à sa victime :
- Soit en envoyant le lien directement à sa victime (ex : phishing)
- Soit en faisant en sorte que la victime visite un site qu'il contrôle et en y incluant par exemple le code suivant :
```HTML
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
```

## Requête POST
L'attaquant se doit de créer un site web malveillant et de faire en sorte que sa victime le visite.

==Exemple :==
L'attaquant crée une page HTML comme suit et fait en sorte que la victime la visite. Si la victime était connecté récemment à vulnerable-website.com et que son cookie de session n'est pas protégé par l'attribut SameSite, il sera envoyé au serveur et l'email de l'utilisateur sera modifié.
```HTML
<html>
	<body>
		<form action="https://vulnerable-website.com/email/change" method="POST">
			<input type="hidden" name="email" value="pwned@evil-user.net" />
		</form>
		<script> document.forms[0].submit(); </script>
	</body>
</html>
```

Avec Burp Suite Professional, il est possible de générer un PoC d'une page HTML comme l'exemple ci dessus simplement en faisant un clic droit sur la requête vulnérable puis en sélectionnant : Engagement tools > Generate CSRF PoC.

# CSRF token bypass
## CSRF token
Un token CSRF est un jeton unique, secret et imprévisible envoyé par le serveur au client et devant être inclus dans la requête du client pour que celle-ci soit valide. C'est une mesure de protection car l'attaquant n'est pas en mesure de deviner la valeur du CSRF token.

Typiquement, le token CSRF peut être partagé par le serveur dans un champ masqué d'un formulaire. Ainsi le client le soumettra sans s'en rendre compte.
Selon l'implémentation, il peut aussi être partagé par le serveur dans un en-tête HTTP.

## Contournement
Le contournement du token CSRF est possible seulement si la validation de celui-ci est mal implémenté.

Les failles les plus courantes sont :
- **La non validation du token CSRF des requêtes GET** : le token CSRF est vérifié sur les requêtes POST uniquement, donc si on peut changer la méthode ou trouver d'autres routes, bingo !
- **La non validation du token CSRF lorsqu'il est absent** : le token CSRF est vérifié lorsqu'il est présent, mais si le paramètre est omis (pas seulement sa valeur mais le paramètre entier), alors il n'est pas vérifié.
  C'est équivalent à l'absence de token CSRF du point de vue de l'attaquant.
- **La non validation que le token CSRF appartienne bien à l'utilisateur** : la validité du token est vérifié parmi le pool de token valide, sans vérifier qu'il appartient bien à l'utilisateur émetteur de la requête. L'attaquant peut donc utiliser son propre token CSRF (il faut qu'il ait déjà un accès sur l'application) dans les requêtes qui seront créées par ses victimes (ex : en ajoutant `<input type="hidden" name="csrf" value="<csrf_value>" />` dans un formulaire).
  *Attention* : un token CSRF est typiquement valide que pour une seule requête, donc il faudra en prendre un neuf jamais soumis.
- **La validation du lien entre le token CSRF et un cookie de session qui n'est pas le cookie d'authentification** : cela peut se produire lorsqu'un framework est utilisé pour géré les sessions et un autre framework est utilisé pour la protection anti-CSRF.
  Il suffit à l'attaquant de mettre dans la requête son token CSRF et son cookie lié au CSRF et le serveur vérifiera seulement ces 2 éléments sans vérifier le lien entre l'utilisateur (cookie de session) et le token CSRF.
  *Attention* : pour exploiter cette faille, l'attaquant doit être en mesure de placer son cookie lié au CSRF dans le navigateur de sa victime, ce qui nécessite la présence et l'exploitation d'une autre vulnérabilité (ex : une autre fonctionnalité set un cookie avec la valeur d'une entrée utilisateur mal protégée).
  *Attention bis* : il est souvent obligatoire de spécifier les attributs Samesite=None et Secure lors de la mise en place d'un cookie sur le navigateur de la victime depuis le site que l'attaquant contrôle.

==Exemple :==
On est dans le dernier cas précédent et il y a une vulnérabilité par conception qui permet de créer un nouveau cookie en exploitant le paramètre `search` dont la valeur est insérée comme suit : `Set-Cookie: LastSearchTerm=<value>; Secure; HttpOnly`.
```HTML
<html>
	<body>
		<form action="https://vulnerable-website.com/email/change" method="POST">
			<input type="hidden" name="email" value="pwned@evil-user.net" />
			<input type="hidden" name="csrf" value="aC64PJXLkzMLFLFD8qQsDeludwD42pdD" />
		</form>
		<img src="https://0vulnerable-website.com/?search=fake; Secure; HttpOnly%0D%0ASet-Cookie: csrfKey=WUnVdADjaPNcYdrkUtq7Ppx4OHFUr4mb; SameSite=None" onerror="document.forms[0].submit()">
	</body>
</html>
```

